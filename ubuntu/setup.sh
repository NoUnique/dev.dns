#!/bin/bash

TARGET_OS=ubuntu
TARGET_OS_VER=(
    18.04
    20.04
)
DNS_CONFIG=dns.conf
HOST_CONFIG=hosts

PATH_RESOLVE_CONF=/etc/systemd/resolved.conf

function fn_main() {
    fn_init
    fn_check_os
    fn_install dconf-cli  # install dconf to set ignore-hosts of proxy
    
    DATETIME=$(date +"%D %T")
    
    DNS_LIST=($(fn_read_conf ${DNS_CONFIG}))
    INTERNAL_DNS_IP=${DNS_LIST[0]}
    DEFAULT_DNS_IPS=${DNS_LIST[@]:1}

    fn_ping_ip ${INTERNAL_DNS_IP}
    for ip in ${DEFAULT_DNS_IPS[@]}; do
        fn_ping_ip ${ip}
    done


    # set proxy exception list
    # read proxy ignore-hosts from gnome settings DB
    IGNORE_HOSTS=$(dconf read /system/proxy/ignore-hosts)
    # convert ignore-hosts to bash array
    IGNORE_HOSTS=($(strlist2array $IGNORE_HOSTS))
    while read line; do
        HOST_INFO=(${line})
        IP=${HOST_INFO[0]}
        for domain in ${HOST_INFO[@]:1}; do
            if [[ $domain == *.* ]]; then
                domain="*.$(echo $domain | sed 's/^\.//g')"
                # add a domain if not exists in array
                if ! [[ " ${IGNORE_HOSTS[*]} " =~ " ${domain} " ]]; then
                    IGNORE_HOSTS+=($domain)
                fi
            fi
        done
    done < ${HOST_CONFIG}
    # convert ignore-hosts array to list-from string
    IGNORE_HOSTS=$(array2strlist ${IGNORE_HOSTS[@]})
    dconf write /system/proxy/ignore-hosts "${IGNORE_HOSTS}"

    
    # write resolve config
    echo -e "\n\n# The following lines are generated by $(realpath $0) at ${DATETIME}" | sudo tee -a ${PATH_RESOLVE_CONF}

    # comment out main DNS setting
    PATTERN="^DNS\="
    echo "sed -i '/${PATTERN}/s/^/#/g' ${PATH_RESOLVE_CONF}"
    sudo_exec "sed -i ""/${PATTERN}/s/^/#/g"" ${PATH_RESOLVE_CONF}"
    
    # comment out fallback DNS settings
    PATTERN="^FallbackDNS\="
    echo "sed -i '/${PATTERN}/s/^/#/g' ${PATH_RESOLVE_CONF}"
    sudo_exec "sed -i ""/${PATTERN}/s/^/#/g"" ${PATH_RESOLVE_CONF}"
   
    # echo to resolve config
    echo "DNS=${INTERNAL_DNS_IP}" | sudo tee -a ${PATH_RESOLVE_CONF}
    echo "FallbackDNS=$(join_by ' ' ${DEFAULT_DNS_IPS[@]})" | sudo tee -a ${PATH_RESOLVE_CONF}


    # restart service
    sudo_exec "systemctl restart systemd-resolved.service"
    sudo_exec "ln -snf /run/systemd/resolve/resolv.conf /etc/resolv.conf"
}


# essential functions
# (omit 'function' keyword to distinguish them from major functions)
exist() {
    local EXECUTABLE=$1
    [[ $(${EXECUTABLE} 2> /dev/null) ]]
}
verlt() {
    [ "$1" = "$2" ] && return 1 || [ "$1" = "$(echo -e "$1\n$2" | sort -V | head -n1)" ]
}
join_by() {
    local d=$1 f=$2
    if shift 2; then
        printf %s "$f" "${@/#/$d}"
    fi
}
sudo_exec() {
    local EXECUTABLE=${1:-"true"}
    local ERROR_MESSAGE=${2:-"Failed to acquire root privileges"}
    local IS_ROOT=false
    if sudo true; then
        IS_ROOT=true
    else
        echo "Root privileges is needed. Please enter your password if you are sudoer"
        sudo -k # make sure to ask for password on next sudo
        if sudo true; then
            IS_ROOT=true
        else
            echo ${ERROR_MESSAGE}
            exit 1
        fi
    fi
    if [[ ${IS_ROOT} == true ]]; then
        $(sudo ${EXECUTABLE})
    fi
}
strlist2array() {
    local list=$@
    unset array
    IFS="', '"
    array=$(echo "$(echo ${list} | cut -c 2- | sed 's/.$//g')")
    unset IFS
    echo ${array[@]}
}
array2strlist() {
    local array=($@)
    unset list
    unset IFS
    for el in ${array[@]}; do
        el="$(echo ${el} | sed 's/ //g')"
        list="${list}, '${el}'"
    done
    list="[$(echo ${list} | cut -c 3-)]"
    echo ${list}
}

function fn_init() {
    # set working directory
    SCRIPT_DIR="$(cd -P -- "$(dirname -- "${BASH_SOURCE[0]}")" && pwd -P)"
    #cd ${SCRIPT_DIR}
    cd ${SCRIPT_DIR}/..
}

function fn_install() {
    local EXECUTABLE=$1
    if [[ $(exist ${EXECUTABLE}) == false ]]; then
        echo "Command '${EXECUTABLE}' not found, install it."
        sudo_exec "apt install -y ${EXECUTABLE}" "${EXECUTABLE} is not installed"
    fi
}

function fn_check_os() {
    # get OS info
    . /etc/os-release
    CURR_OS=$ID
    CURR_OS_VER=$VERSION_ID

    # check OS version requirements
    echo "OS distribution target - required: ${TARGET_OS}, curr: ${CURR_OS}"
    if [[ ${TARGET_OS} -eq ${CURR_OS} ]]; then
        echo " => matched"
    else
        echo " => not matched"
        exit 1
    fi
    echo "OS version requirements - required: ${TARGET_OS_VER[@]}, curr: ${CURR_OS_VER}"
    local IS_MATCHED=0
    for OS_VER in ${TARGET_OS_VER[@]}; do
        if [[ ${CURR_OS_VER} == ${OS_VER} ]]; then
            IS_MATCHED=1
            break
        fi
    done
    if [[ ${IS_MATCHED} -eq 1 ]]; then
        echo " => satisfied"
    else
        echo " => not satisfied"
        exit 1
    fi
}

function fn_read_conf() {
    if [[ -f "${1}" ]]; then
        echo $(cat ${1})
    fi
}

function fn_ping_ip() {
    local TARGET_IP=$1
    echo "Target IP: ${TARGET_IP}"
    ping -c 1 -w 2 ${TARGET_IP} &> /dev/null # wait response for 2 seconds
    if [[ $? -eq 0 ]]; then
        echo " => reachable"
    else
        echo " => not reachable"
        exit 1
    fi
}


fn_main
