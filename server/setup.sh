#!/bin/bash

TARGET_OS=ubuntu
TARGET_OS_VER=(
    18.04
    20.04
)
DNS_CONFIG=dns.conf
HOST_CONFIG=hosts

PATH_DNSMASQ_CONF=/etc/dnsmasq.conf
PATH_HOSTS_CONF=/etc/hosts


function fn_main() {
    fn_init
    fn_check_os

    DATETIME=$(date +"%D %T")

    # check the current machine's IP
    DNS_LIST=($(fn_read_conf ${DNS_CONFIG}))
    TARGET_IP=${DNS_LIST[0]}
    MY_IP=$(fn_get_ip)
    if [[ ${MY_IP} != ${TARGET_IP} ]]; then
        echo "This computer's IP is not correct to configuration(${TARGET_CONFIG})"
        echo "Please check IP and configuration"
        echo "IP address of this computer: ${MY_IP}"
        echo "IP address in the ${DNS_CONFIG}: ${TARGET_IP}"
        exit 1
    fi
    if [[ $(fn_check_port) == true ]] && [[ $(fn_check_resolve) == true ]]; then
        fn_disable_resolve
        fn_install dnsmasq
    fi

    # write dnsmasq config
    sudo_exec # get root privileges first to access to /etc
    sudo tee ${PATH_DNSMASQ_CONF} << EOF
# The following lines are generated by $(realpath $0) at ${DATETIME}
no-resolv
listen-address=::1,127.0.0.1  # loopback
listen-address=127.0.0.53  # local dns
listen-address=${TARGET_IP}
cache-size=1000
EOF
    for ip in ${DNS_LIST[@]:1}; do
        fn_ping_ip ${ip}
        echo "server=${ip}" | sudo tee -a ${PATH_DNSMASQ_CONF}
    done
    # add address from hostfile
    while read line; do
        HOST_INFO=(${line})
        IP=${HOST_INFO[0]}
        for domain in ${HOST_INFO[@]:1}; do
            if [[ $domain == *.* ]]; then
                echo "address=/${domain}/${IP}" | sudo tee -a ${PATH_DNSMASQ_CONF}
            fi
        done
    done < ${HOST_CONFIG}
    
    # write host config
    echo -e "\n\n# The following lines are generated by $(realpath $0) at ${DATETIME}" | sudo tee -a ${PATH_HOSTS_CONF}
    while read line; do
        HOST_INFO=(${line})
        # comment out host address that already exists in hostfile
        IP=${HOST_INFO[0]}
        echo "@@@$IP@@@"
        PATTERN="^$(escape ${IP})[[:blank:]]"
        echo $PATTERN
        echo "sed -i ""/${PATTERN}/s/^/#/g"" ${PATH_HOSTS_CONF}"
        sudo_exec "sed -i ""/${PATTERN}/s/^/#/g"" ${PATH_HOSTS_CONF}"

        # echo to hostfile
        echo -e "$(join_by "\t" ${HOST_INFO[@]})" | sudo tee -a ${PATH_HOSTS_CONF}
    done < ${HOST_CONFIG}

    # restart dnsmasq to apply configurations
    #sudo_exec "systemctl restart dnsmasq"
    sudo_exec "systemctl start dnsmasq"
}


# essential functions
# (omit 'function' keyword to distinguish them from major functions)
exist() {
    command -v "$1" &>/dev/null
    if [[ $? -eq 0 ]]; then
        echo true
    else
        echo false
    fi
}
verlt() {
    [ "$1" = "$2" ] && echo true || [ "$1" = "$(echo -e "$1\n$2" | sort -V | head -n1)" ]
}
join_by() {
    local d=$1 f=$2
    if shift 2; then
        printf %s "$f" "${@/#/$d}"
    fi
}
escape() {
    local STRING=$1
    echo $(printf "%s" "$1" | sed -e 's/[]\/$*.^[]/\\&/g')
}
sudo_exec() {
    local EXECUTABLE=${1:-"true"}
    local ERROR_MESSAGE=${2:-"Failed to acquire root privileges"}
    local IS_ROOT=false
    if sudo true; then
        IS_ROOT=true
    else
        echo "Root privileges is needed. Please enter your password if you are sudoer"
        sudo -k # make sure to ask for password on next sudo
        if sudo true; then
            IS_ROOT=true
        else
            echo ${ERROR_MESSAGE}
            exit 1
        fi
    fi
    if [[ ${IS_ROOT} == true ]]; then
        sudo ${EXECUTABLE}
    fi
}

function fn_init() {
    # set working directory
    SCRIPT_DIR="$(cd -P -- "$(dirname -- "${BASH_SOURCE[0]}")" && pwd -P)"
    #cd ${SCRIPT_DIR}
    cd ${SCRIPT_DIR}/..
}

function fn_install() {
    local EXECUTABLE=$1
    if [[ $(exist ${EXECUTABLE}) == false ]]; then
        echo "Command '${EXECUTABLE}' not found, install it."
        sudo_exec "apt install -y ${EXECUTABLE}" "${EXECUTABLE} is not installed"
    fi
}

function fn_check_os() {
    # get OS info
    . /etc/os-release
    CURR_OS=$ID
    CURR_OS_VER=$VERSION_ID

    # check OS version requirements
    echo "OS distribution target - required: ${TARGET_OS}, curr: ${CURR_OS}"
    if [[ ${TARGET_OS} -eq ${CURR_OS} ]]; then
        echo " => matched"
    else
        echo " => not matched"
        exit 1
    fi
    echo "OS version requirements - required: ${TARGET_OS_VER[@]}, curr: ${CURR_OS_VER}"
    local IS_MATCHED=false
    for OS_VER in ${TARGET_OS_VER[@]}; do
        if [[ ${CURR_OS_VER} == ${OS_VER} ]]; then
            IS_MATCHED=true
            break
        fi
    done
    if [[ ${IS_MATCHED} == true ]]; then
        echo " => satisfied"
    else
        echo " => not satisfied"
        exit 1
    fi
}

function fn_check_port() {
    local IN_USE=false
    # check whether port 53 in use
    if (( $(ss -lp "sport = :domain" | wc -l) > 1 )); then
        IN_USE=true
    fi
    echo ${IN_USE}
}

function fn_check_resolve() {
    # check whether systemd-resolv is active
    local IS_ACTIVE=false
    EXECUTABLE="systemd-resolve --status"
    if [[ $(exist systemd-resolve) == true ]]; then
        IS_ACTIVE=true
    fi
    echo ${IS_ACTIVE}
}

function fn_disable_resolve() {
    sudo_exec "systemctl disable systemd-resolved"
    sudo_exec "systemctl mask systemd-resolved"
    sudo_exec "systemctl stop systemd-resolved"
}

function fn_enable_resolve() {
    sudo_exec "systemctl unmask systemd-resolved"
    sudo_exec "systemctl enable systemd-resolved"
    sudo_exec "systemctl start systemd-resolved"
}

function fn_get_ip() {
    EXTERNAL_IP=$(hostname -I | cut -d: -f2 | awk '{ print $1 }')
    # the following code only works after 18.04 since ip v4 address is printed as 'inet addr: <ip>' in ifconfig(net-tools) < 2.x
    #fn_install net-tools
    #EXTERNAL_IP=$(ifconfig | grep 'inet ' | grep -v '127.0.0.1' | grep -v 'inet 172.' | grep -v 'inet 192.' | head -n 1 | cut -d: -f2 | awk '{ print $2}')
    echo ${EXTERNAL_IP}
}

function fn_read_conf() {
    if [[ -f "${1}" ]]; then
        echo "$(cat ${1})"
    fi
}

function fn_ping_ip() {
    local TARGET_IP=$1
    echo "Target IP: ${TARGET_IP}"
    ping -c 1 -w 2 ${TARGET_IP} &> /dev/null # wait response for 2 seconds
    if [[ $? -eq 0 ]]; then
        echo " => reachable"
    else
        echo " => not reachable"
        exit 1
    fi
}


fn_main
